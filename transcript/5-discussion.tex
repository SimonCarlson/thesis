\documentclass[0-thesis.tex]{subfiles}

\begin{document}
% TODO: Introductory blurb

\section{Conclusions}
\label{sec:Conclusions}
% TODO: Conclusions drawn from qualitative evaluation?
% Results to answer the research question
% I think it will mostly be backed by the qualitative results (since the question is how)
% Quantitative can be used to back up claims of feasability and future focus
The thesis has presented a software and firmware update architecture for IoT. The
architecture is based on requirements developed by the IETF SUIT working group and aims to
be interoperable and usable for very constrained devices and state-of-the art security
mechanisms such as asymmetric cryptography, certificates, and authorization tokens. The
architecture defines the roles of devices, update servers, and operators, discusses how
these actors can authorize themselves and what tokens are needed, the operations of these
actors such as registering devices, and briefly considers local upgrade handling.
Furthermore the thesis discusses the device life cycle for new devices entering a network,
being updated, and continuing their service for many years, where devices must re-register
and possibly re-enroll following certain operations of an update procedure. Two different
profiles for the architecture, one using DTLS and CoAP and the other OSCORE, were
presented and the DTLS/CoAP profile was implemented in a prototype with some restrictions.

Measuring code size of the update client and server as well as a bare-bones Contiki-NG
example, it is evident that the solution can be applied to very constrained systems. The
difference in size between the client and bare-bones example is 8286 bytes and the server
and bare-bones example is 8586 bytes. In a real deployment the code size will increase as
the prototype's manifest parser is rudimentary and the client does not contain any code
for preparing the bootloader, but applying the architecture to constrained devices is
still feasible.

Experiments on energy consumption found that transfering the image data makes up the vast
majority of energy consumed during an update procedure. This is due to the register
operations and sending/receiving of a manifest sends a lot less data. Also when the client
parses the manifest the operations are entirely local to the client, not using any
expensive radio operations. During image transfer the largest source of energy consumption
is the radio in receive mode followed by the CPU in Low Power Mode. The amount of time
thus energy needed for the transfer scales linearly with the size of the data being sent,
meaning opportunities to send less data are of importance when it comes to saving energy.

The architecture introduces some communication overhead on the application layer when
sending both manifest and image data. When encrypting with COSE a 8-byte tag is added for
validation to the ciphertext. In the case of the manifest this tag is added once as the
manifest is small enough to be encrypted at once. For the much larger image data, which
cannot be encrypted all at once, each block is encrypted individually instead. This means
that each block introduces 8 bytes of tag for each 32 bytes of data sent in a CoAP block.
By sending less data a smaller amount of blocks must be transfered meaning less overhead
is sent in total. This furthers the argument for exploring opportunities that reduce the
amount of data sent, such as differential updates.

\section{Security Considerations}
\label{sec:security-considerations}
Despite being able to add timestamps in the manifest specifying a time of update it can
prove difficult to install updates at the right moment. Timestamps are also unable to
account for if processes are being interrupted or not, one might want to postpone updates
until a certain process or thread is idle. Not having fine-grained controlled over when an
update is installed is especially important for devices used in safety critical contexts
such as in factories

The architecture does not support scenarios where redundant devices are used to achieve
the same goal, such as monitoring equipment. To update one of the devices while the other
operates and then update the other would require manual intervention such as sending the
devices updates one at a time. This is a rather brittle approach and having support for
twinned devices would help safety critical contexts.

The architecture does not account for physical threats, only threats that arise during
wireless transport. The discussion in Section~\ref{ssec:upgrading} does not account for
scenarios where the physical storage of devices is compromised. Implementers are advised
to store manifest and image data in a way that makes sense for their own deployment,
whether that is unencrypted, encrypted, or encrypted manifest with unencrypted image.

\section{Future Work}
\label{sec:future-work}
Moving forward, research on preparing bootloaders for upgrades and safe boot as well as
performing differential updates would be of importance. As the results showed, the largest
source of energy consumption is the radio receiver during transfer of updates, largely
because of the relatively large size of firmware images. By performing differential
updates instead the size of images can be reduced and time to retrieve them and thus
energy consumption will go down. Furthermore, developing a prototype using certificates
instead of pre-shared DTLS keys, authorization tokens, and COSE signing instead of
encryption would further aid the understanding of the architecture's requirements on
devices and how feasible it is to use for less constrained devices conscerning code size
and energy consumption. 

\end{document}