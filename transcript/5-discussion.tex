\documentclass[0-thesis.tex]{subfiles}

\begin{document}
This thesis has presented a software and firmware update architecture for IoT. The
architecture is based on requirements developed by the IETF SUIT working group and aims to
be interoperable and usable for constrained devices using state-of-the art security
mechanisms such as asymmetric cryptography, certificates, and authorization tokens. The
architecture defines the roles of devices, update servers, and operators, and discusses
how these actors can authorize themselves, what tokens might be needed, and the operations
of these actors, such as registering devices, and briefly considers local upgrade handling.
Furthermore, the thesis discusses the device life cycle for new devices entering a network,
being updated, and continuing their service for many years. Two different profiles for the
architecture, one using DTLS and CoAP and the other OSCORE, were presented, and the
DTLS/CoAP profile was implemented in a prototype with some restrictions.

The requirements from the SUIT architecture and information model specifications were
evaluated against the proposed architecture. The requirements, with the exception of
bootloader-specific requirements, were all satisfied, as the proposed architecture was
developed with compliance with SUIT in mind. Fundamental requirements such as being
agnostic to distribution methods, using state-of-the-art security mechanisms, and
operating with robust permissions, are part of the core architecture. Other requirements
such as broadcast-friendliness and small parsers are implementation-specific but were
prepared for and supported in the architecture.

When it comes to the information model, the proposed architecture was designed for
flexibility. This means the manifest implementation implemented all mandatory elements as
a baseline and moved remaining functionality into optional elements. Many requirements
related to the information model were directly covered by the baseline manifest, while
others were accounted for by enabling implementation of niche manifest elements. The
reasoning was to provide a minimal manifest implementation, thus reducing size and
complexity while allowing for custom implementations of new pre- and post-conditions,
directives, and other information. The flexibility should provide more robustness, as the
update mechanism can operate in a way that makes most sense in a specific deployment,
while keeping the baseline manifest intact, thus ensuring the minimum level of security
sought for is reached. 

With the qualitative results in mind, the proposed architecture is a way of applying the
SUIT specification to constrained, heterogeneous networks of devices in order to provide
an interoperable update mechanism. The architecture fulfilled the requirements developed
by the SUIT specification, used modern security solutions, and had a flexible design, so
it can be applied in various contexts. Networks of different devices with different
applications and operating systems can all take part in the update architecture using the
methods presented in the thesis.

In order to contextualize the proposed architecture, a DTLS/CoAPs prototype was developed.
By measuring code size of the update client and server as well as a bare-bones Contiki-NG
example, it was evident that the solution can feasibly be applied to constrained systems.
The difference in size between the client and bare-bones example is 8286 bytes, and
between the server and bare-bones example is 8586 bytes. In a real deployment, the code
size will increase as the prototype's manifest parser is rudimentary and the client does
not contain any code for preparing the bootloader. Also, the server needs stronger logic
for handling device profiles and manifests, but applying the architecture to constrained
devices is still feasible.

Experiments on energy consumption found that receiving the image data makes up the vast
majority of energy consumed during an update procedure. This is due to the register
operations and sending and receiving of a manifest transfers uses, comparatively, very
little data. Also, when the client parses the manifest, the operations are entirely local
to the client, and do not use any expensive radio operations. During image transfer, the
largest source of energy consumption was the radio in receive mode which, for the client,
was up to 83\% and server 81\% of total energy consumption during image transfer. The
amount of time thus energy needed for the transfer scaled linearly with the size of the
data being sent, meaning opportunities to send less data are of importance when it comes
to saving energy.

The architecture introduced some communication overhead on the application layer when
sending both manifest and image data. When encrypting with COSE a 8-byte tag was added to
the ciphertext for validation. In the case of the manifest this tag was added once as the
manifest was small enough to be encrypted at once. For the much larger image data, which
could not be encrypted all at once, each block was encrypted individually instead. This
meant that each block introduced 8 bytes of tag for each 32 bytes of data sent in a CoAP
block. By sending less data a smaller amount of blocks have to be transferred meaning less
overhead is sent in total. This furthers the argument for exploring opportunities that
reduce the amount of data sent, such as differential updates.

\section{Security Considerations}
\label{sec:security-considerations}

\subsubsection{Timing of Updates}
Despite being able to add timestamps in the manifest specifying a time of update it can
prove difficult to install updates at the right moment. Timestamps are also unable to
account for if processes are being interrupted or not. One might want to postpone updates
until a certain process or thread is idle. Not having fine-grained controlled over when an
update is installed is especially important for devices used in safety critical contexts,
such as in factories.

\subsubsection{Redundant Devices}
The architecture does not support scenarios where redundant devices are used to achieve
the same goal, such as with monitoring equipment. To update one of the devices while the other
operates and then update the other would require manual intervention such as sending the
devices updates one at a time. This is a rather brittle approach, and having support for
twinned devices would help safety-critical applications.

\subsubsection{Physical Threats}
The architecture does not account for physical threats, only threats that arise during
wireless transport. The discussion in Section~\ref{ssec:upgrading} does not account for
scenarios where the physical storage of devices is compromised. Implementers are advised
to store manifest and image data in a way that makes sense for their own deployment,
whether that is unencrypted, encrypted, or encrypted manifest with unencrypted image.

\subsubsection{Importance of the Certificate Authority}
The certificate authority plays a central role in the architecture as everything is based
on certificates being available. If the CA is breached, unavailable, or for some other
reason deemed untrustworthy nothing will work properly. Providing devices with correct CA
certificates and upholding the integrity of the CA is essential for the architecture to
function.

\subsubsection{Battery Draining Attacks}
Battery draining attacks should be prevented due to devices keeping whitelists of
operators and update servers, disallowing communication from other sources, in combination
with certificates that can further prove their identity. Should an attacker be able to
send messages to devices, the push model makes it so devices would accept and parse
manifests in order to check if the update is valid or not. If large amounts of data in the
form of manifests are sent to devices, their batteries can deplete quicker due to
repetitive decryption and parsing. The issue stems from devices immediately responding to
pushed update with performing calculations, which enables these kinds of attacks.


\section{Future Work}
\label{sec:future-work}
Moving forward, research on preparing bootloaders for upgrades and safe boot as well as
performing differential updates would be of importance. As the results showed, the largest
source of energy consumption is the radio receiver during transfer of updates, largely
because of the relatively large size of firmware images. By performing differential
updates instead, the size of images can be reduced, and time to retrieve them and thus
energy consumption will go down. Furthermore, developing a prototype using certificates
instead of pre-shared DTLS keys, authorization tokens, and COSE signing instead of
encryption would further aid the understanding of the architecture's requirements on
devices and how feasible it is to use for less constrained devices concerning code size
and energy consumption. 

\end{document}