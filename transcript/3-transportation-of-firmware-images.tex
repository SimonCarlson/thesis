\documentclass[0-thesis.tex]{subfiles}

\begin{document}
% TODO: Dedicate this to transportation CoAP -> DTLS -> UDP
% TODO: Also format of manifest
% TODO: Encoding? CBOR?

\section{Manifest Format}
\label{sec:manifest-format}
% General intro to the chapter
% Maybe state assumptions about storage and computational capability of target devices?
As the target devices of the update mechanism are constrained IoT devices, the manifest
format must be designed with careful consideration. The format must be easy to parse in
order to reduce power consumption on devices and be small so that transportation of the
manifest is done as quickly as possible, but still contain all necessary information to
perform secure updates. This section will present the manifest format which is based on
the SUIT specification. It consists of mandatory, always present elements as well as
optional elements. The reasoning for splitting it into mandatory and optional elements is
to reduce the size of the common case, a singular update for a single \gls{mcu}, while
still allowing more complex updates (such as differential updates or specifying
components). The manifest format can be created or generated by some party in \gls{json},
encoded in \gls{cbor} for efficient compression, then signed and sent over the network.
Preferably the base manifest should fit in a single CoAP message, but the CoAP block
option can be used if the manifest adds many options and thus grows.
%As a rule of thumb, each byte sent expends as
%much energy as roughly 8000 CPU cycles, so reducing the size of the manifest is of
%importance \parencite{interconnecting}.

Section~\ref{ssec:mandatory-elements} explains the structure of the manifest. Optional
elements and their structure are explained in Section~\ref{ssec:options}. 

\subsection{Mandatory Elements}
\label{ssec:mandatory-elements}
% Show header format, motivate sizes
The mandatory elements of the manifest should facilitate singular updates for a homogeneous
device supporting one MCU as this is the simplest use case for secure updates. This use
case updates the entire image at once, OS and code, and does not need to care for
different storage locations or components. By restricting the mandatory elements to
supporting these kinds of updates, the size of the always occurring elements can be
reduced. 

Different versions of manifests can feature different fields as an update mechanism
evolves, therefore the device needs to know what to expect from the manifest. This can be
encoded in a \textbf{manifest version ID}. Rollback attacks need to be prevented so that
old, vulnerable images cannot be applied. They can be mitigated through a \textbf{sequence
number}. Furthermore the \textbf{format} (ELF, binary, etc) and the \textbf{size} of the
image must be included. \textbf{Vendor and class IDs} must also be included so that the
device knows the image is applicable and will work. Lastly, a \textbf{digest} of the image
must be included so the device can be sure the image has not been tampered with during
transport. The \textbf{URI} from which the image can be fetched is bundled together with
the digest. The manifest structure expressed as a C struct can be seen in Listing
\ref{lst:manifest-struct}.

\begin{lstlisting}[language=blockc,
                    caption={The mandatory manifest format.}, 
                    label={lst:manifest-struct}]
    struct Manifest {
        int version;
        int sequenceNumber;
        int format;
        int size;
        Condition* condition;
        URIDigest* digest;
        Option* option;
    } Manifest;
\end{lstlisting}

These elements are deemed absolutely necessary and form the very minimum upon which an
update mechanism can operate. A manifest containing these and only these elements can be
used to perform a singular update for a device containing one MCU and one means of storage
(no ambiguity about which components/locations are being updated).

The digests, conditions, and options are nested structures that can possibly be repeated
depending on how many digests, conditions, and options are necessary. In order to
implement this, each of these structures contain an element which is a pointer to another
structure of the same type. This allows a parser to traverse the link of structures, and
thus parse several URI/Digest pairs, conditions, or options. Their structures can be seen
in Listing~\ref{lst:uridigest-struct}, Listing~\ref{lst:condition-struct}, and
Listing~\ref{lst:option-struct} in the next section.

\begin{lstlisting}[language=blockc,
                    caption={The format of URI/digest pairs.}, 
                    label={lst:uridigest-struct}]
    struct URIDigest {
        int URILength;
        char* URI;
        char* digest;
        URIDigest* next;
    } URIDigest;
\end{lstlisting}

\begin{lstlisting}[language=blockc,
                    caption={The format of vendor and class ID conditions.}, 
                    label={lst:condition-struct}]
    struct Condition {
        int type;
        char* UUID;
        Condition* next
    } Condition;
\end{lstlisting}

\subsection{Options}
\label{ssec:options}
% Show options format, motivate sizes
The options provide additional value to the mechanism, but as the manifest aims to be as
small as possible they are not accounted for in the base manifest. Instead they can be
optionally included using the options field of the manifest. The included options must be
sorted by their option code in ascending order to calculate a delta between the current
and preceding option. This is the way CoAP implements options, and it allows for a
smaller amount of bits to encode the option code when the codes get larger. The options
and their codes are presented in Table~\ref{tab:option-codes}.

\begin{longtable}[]{@{}ll@{}}
    \caption{The optional elements of the manifest and their option codes.}
    \label{tab:option-codes}\\
    \toprule
    Option Code & Option Name\tabularnewline
    \midrule
    \endhead
    1 & directives (Instruction struct)\tabularnewline
    2 & processingSteps (Instruction struct)\tabularnewline
    3 & URIs (mirrors)\tabularnewline
    4 & component\tabularnewline
    5 & dependencies (URIDigest struct)\tabularnewline
    6 & precursors (URIDigest struct)\tabularnewline
    7 & aliases (URIDigest struct)\tabularnewline
    8 & storage\tabularnewline
    9 & keyDist\tabularnewline
    10 & best-before\tabularnewline
    11 & payload (if small enough)\tabularnewline
    \bottomrule
\end{longtable}
    

The option field in the manifest format will contain a list of option structures, each
structure consisting of an option delta, option length, option value, and a pointer to the
next option as seen in Listing~\ref{lst:option-struct}. As with the mandatory elements,
some options consist of nested structs. The dependencies and precursor options list
digests of images or parts of images that must be acquired before applying the update,
along with their URLs. Aliases lists alternative mirrors for each image that could be used
instead. Directives and processingSteps both use a different kind of structure, an
Instruction struct, that maps types of instructions to their values. Examples of
directives could be whether to install the update right away or just cache the image and
install at some later point, and examples of processingSteps could be which decompression
algorithm to use. The Instruction struct can be seen in Listing~\ref{lst:instruction}.

\begin{lstlisting}[language=blockc,
                    caption={The format of the option field.}, 
                    label={lst:option-struct}]
    struct Option {
        int delta;
        int length;
        char* value;
        Option* next;
    } Option;
\end{lstlisting}

\begin{lstlisting}[language=blockc,
                    caption={The format of directives or processing steps.}, 
                    label={lst:instruction}]
    struct Instruction {
        int type;
        int value;
        Instruction* next;
    } Instruction;
\end{lstlisting}

\subsection{Example Manifest}
\label{ssec:example-manifest}
JSON is a human readable and easily modified format. It is easy to convert JSON, which is
quite verbose, into CBOR as a more efficient means of encoding the data. CBOR was designed
around the same principles and elements as JSON, but is not very readable for humans. For
these reasons, the thesis proposes to craft manifests in JSON, then convert into CBOR, and
finally sign and send to the device requiring an update. An example manifest could look as
in Listing~\ref{lst:example-manifest}.

\begin{lstlisting}[language=blockjson,
                    caption={An example manifest.},
                    label={lst:example-manifest},
                    escapechar=\%]
    {
        "versionID": 1,
        "sequenceNumber": 1,
        "format": 0,
        "size": 512,
        "conditions": [
            {
                "type": 0,
                "UUID": "74738ff5-5367-5958-9aee-98fffdcd1876"
            },
            {
                "type": 1,
                "UUID": "28718ff5-9302-8217-7auu-14llldsd1276"
            }
        ],
        "digests": [
            {
                "URI": "coap://fake.uri/image",
                "digest": "b924842b4f42 %$\dots$% ecf3301985"
            }
        ],
        "options": [
            {
                "delta": 4,
                "length": 1,
                "value": 0
            },
            {
                "delta": 6,
                "length": 10,
                "value": 1548683522
            }
        ]
    }
\end{lstlisting}

This manifest contains all the mandatory information and two options. There are two
conditions telling the vendor and class ID so that the device knows the update is
correctly targeted. There is only one URI/digest pair, giving the device the URI to
download the image from and the digest to validate the image with. The two options
specified are the component and best-before timestamp options. The component option value
can for instance map integers to components to be updated, and the best-before timestamp
prevents the device from applying the device if that moment in time has been exceeded. The
manifest is easy to read but as it is JSON it is unnecessarily verbose. By encoding it in
CBOR, which is a binary encoding, it will shrink in size and thus cost less to receive.

\begin{lstlisting}[language=blockjson,
                    caption={The first four elements of the example manifest in CBOR encoding.},
                    label={lst:example-manifest-cbor}]
A7                                      # map(7)
   69                                   # text(9)
      76657273696F6E4944                # "versionID"
   01                                   # unsigned(1)
   6E                                   # text(14)
      73657175656E63654E756D626572      # "sequenceNumber"
   01                                   # unsigned(1)
   66                                   # text(6)
      666F726D6174                      # "format"
   00                                   # unsigned(0)
   64                                   # text(4)
      73697A65                          # "size"
   19 0200                              # unsigned(512)
\end{lstlisting}

Listing~\ref{lst:example-manifest-cbor} shows the first four elements of the example
manifest when encoded in CBOR. The structure of mapping keys to values is the same, but
each element is preceded by an indication of type and length. This allows for arbitrarily
nested elements and indefinite length items. It also allows for a more efficient encoding
of elements since if the size is known beforehand, only the required amount of bits can be
used instead of preallocating bits and wasting them on shorter items.

% TODO: More concrete? Code snippets of parsing?
The example manifest would be transmitted to a device and then parsed. The parser would
divide the manifest into the structures shown in sections \ref{ssec:mandatory-elements}
and ref{ssec:options}. The parsed manifest structure would have an option struct
referencing another option struct, meaning the chain is of length 2. The reason for having
the nested structs carry a reference to its own type is to make memory allocation easier.
While parsing, when the parser detects a new nested struct will be created it can simply
allocate that memory and add it in the chain of structs. There is no need to preallocate a
large enough block of memory to make sure the structs will fit. Finally, when the manifest
is parsed and analyzed, the update itself can take place. This is a topic for the next
chapter.

\end{document}