 \documentclass[0-thesis.tex]{subfiles}

\begin{document}
This chapter presents the theoretical background needed to understand the thesis. Section
\ref{sec:network} introduces the networks protocols used and motivates their use over
other protocols in an IoT context. Section \ref{sec:hardware} presents the target hardware
for this thesis. The following section, Section \ref{sec:suit} presents and explains the
SUIT architecture and information model and their respective requirements as formulated by
the IETF. Section \ref{ssec:contiki-ng} presents the Contiki-NG operating system which the
updating mechanism will be developed for, and finally \ref{ssec:pki} introduces EST-CoAP
which is a protocol for public key certificate distribution. 

\section{IoT Network Stack}
\label{sec:network}
Network protocols in IoT networks operate under different circumstances compared to
traditional computer networks. Networks in IoT are defined by their low power
requirements, low reliability, and low computational performance on edge devices. This
posts some constraints on the protocols used as they must be suitable for use in IoT
networks. One of the most widely used network protocol stacks today in traditional
networks is the TCP/IP stack. It uses TCP as a transportation protocol, usually with TLS
for security, and a common application layer protocol is HTTP. TCP is however poorly
suited for IoT networks as it is a connection based, stateful protocol which tries to
ensure the guaranteed delivery of packets in the correct order. There is also advanced
congestion control mechanisms in TCP which are hard to apply on low-bandwitch, unreliable
networks.

IoT networks on the other hand often utilize UDP for transport. UDP is also an IP-based
protocol which grants some interoperability with traditional networks while performing
better in IoT contexts. As TLS is based on the same assumptions TCP does it is unsuitable
for UDP networks. Instead there is DTLS, which is a version of TLS enhanced for use in
datagram oriented protocols such as UDP. HTTP can be used over UDP for the application
layer, but as HTTP is encoded in human readable plaintext it is unecessarily wordy and not
optimal for constrained networks. Instead, CoAP is a common protocol for the application
layer in IoT networks. Figure \ref{fig:stack-comparison} shows the equivalent protocols
for IoT network stacks versus traditional network stacks. 

In this chapter, subsection \ref{ssec:udp} explains UDP and why UDP is preferable in
IoT networks. Subsection \ref{ssec:dtls} briefly explains TLS, why it is unsuitable for
IoT networks, the differences between TLS and DTLS and why DTLS is used. Lastly subsection
\ref{ssec:coap} describes the CoAP protocol.

\begin{figure}
    \begin{bytefield}[bitformatting=\small, bitwidth=1.1em]{30}
        \bitbox[]{12}{IoT stack} & \bitbox[]{4}{} & \bitbox[]{12}{Traditional stack}\\
        \bitbox{12}{CoAP(s)} & \bitbox[]{4}{$\Longleftrightarrow$} \bitbox{12}{HTTP(S)}\\
        \bitbox{6}{UDP} & \bitbox{6}{DTLS} & \bitbox[]{4}{$\Longleftrightarrow$} \bitbox{6}{TCP} & \bitbox{6}{TLS}\\
        \bitbox{12}{IPv6} & \bitbox[]{4}{$\Longleftrightarrow$} \bitbox{12}{IPv4 or IPv6}\\
        \bitbox{6}{IEEE 802.15.4} & \bitbox{6}{6LoWPAN} & \bitbox[]{4}{$\Longleftrightarrow$} \bitbox{12}{IEEE 802.15.4}\\
        \bitbox{12}{IEEE 802.15.4} & \bitbox[]{4}{$\Longleftrightarrow$} \bitbox{12}{IEEE 802.15.4}\\
    \end{bytefield}
    \caption{Comparison of network stacks between IoT networks and traditional networks.}
    \label{fig:stack-comparison}
\end{figure}

\subsection{UDP}
\label{ssec:udp}
UDP is a stateless and asynchronous transfer protocol for IP \parencite{rfc768}. It does
not provide any reliability mechanisms but is instead a best-effort protocol. It also does
not guarantee delivery of messages. For general purposes in unconstrained environments TCP
is usually the favored transport protocol as it is robust and reliable, but in
environments where resources are scarce and networks unreliable, a stateful protocol like
TCP could face issues. Since TCP wants to ensure packet delivery, it will retransmit
packages generating a lot of traffic and processing required for a receiver. Also, if the
connection is too unstable TCP will not work at all since it can no longer guarantee the
packets arrive. The best-effort approach of UDP is favorable in these situations, in
addition to UDP being a lightweight protocol.

Figure \ref{fig:udp-header} shows the UDP header format. The source port is optional, the
length denotes the length of the datagram (including the header), and the checksum is
calculated on a pseudo-header constructed from both the IP header, UDP header, and data.

\begin{figure}
    \begin{bytefield}[bitformatting=\small, bitwidth=1.1em]{32}        
        \bitheader{0-31}\\
        \bitbox{16}{Source port} & \bitbox{16}{Destination port}\\
        \bitbox{16}{Length} & \bitbox{16}{Checksum}\\
        \bitbox[tlb]{32}{Data octets $\dots$}\\
    \end{bytefield}
    \caption{The UDP header format.}
    \label{fig:udp-header}
\end{figure}

\subsection{DTLS}
\label{ssec:dtls}
DTLS is a protocol which adds privacy to datagram protocols like UDP \parencite{rfc6347}.
The protocol is designed to prevent eavesdropping, tampering, or message forgery. DTLS is
based on TLS, a similar protocol for stateful transport protocols such as TCP, which would
not work well on unreliable networks. The main issues with using TLS over unreliable
networks is that TLS decryption is dependant on previous packets, meaning decryption of a
packet would fail if the previous packet was not received, as well as the TLS handshake
procedure assumes all handshake messages are delivered reliably.

DTLS solves this by banning stream ciphers, effectively making decryption an independent
operation between packets, as well as adding explicit sequence numbers. Furthermore, DTLS
supports packet retransmission, reordering, as well as fragmenting DTLS handshake messages
into several DTLS records. These mechanisms makes the handshake process feasible over
unreliable networks. By splitting messages into different DTLS records, fragmentation at
the IP level can be avoided since a DTLS record is guaranteed to fit an IP datagram. IP
fragmentation is problematic is low-performing networks since if a single fragment of an
IP packet is dropped all fragments of that packet must be retransmitted. Since DTLS is
designed to correctly handle reordering and retransmission in lossy networks, splitting
messages into several DTLS records is no problem, and if one record is lost only that
record needs to be retransmitted

Listing \ref{lst:dtls-plain} shows the DTLS record structure. It contains a TLS 1.2 type
field, a version field which for DTLS 1.2 is 254.253, an epoch counter that is incremented
for each cipher state change, an increasing sequence number (unique to each epoch), a
length field and a fragment field containing the application data \parencite{rfc5246}.
These fields, with the exception of the epoch and sequence number, are the same 
as in TLS 1.2 \parencite{rfc6347}.

\lstset{language=C}
\begin{lstlisting}[caption={The DTLS plaintext record structure.}, label={lst:dtls-plain}]
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;
        uint48 sequence_number;
        uint16 length;
        opaque fragment[DTLSPlaintext.length];
    } DTLSPlaintext;
\end{lstlisting}

\begin{lstlisting}[caption={The DTLS ciphertext record structure.}, label={lst:dtls-cipher}]
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;
        uint48 sequence_number;
        uint16 length;
        select (CipherSpec.cipher_type) {
            case block: GenericBlockCipher;
            case aead: GenericAEADCipher;
        } fragment;
    } DTLSCiphertext;
\end{lstlisting}

TLS records are compressed and then encrypted, the same holds for DTLS. When initating
contact, a compression algorithm is chosen. The DTLSPlaintext is then compressed into a
DTLSCompressed record, with similar structure to Listing \ref{lst:dtls-plain}.The
compressed record is encrypted into a DTLSCiphertext record whose structure is shown in
Listing \ref{lst:dtls-cipher}. Note that since DTLS disallows stream ciphers they are not
an option in the encrypted fragment, whereas in TLS they are.

In order to communicate via TLS and DTLS, a handshake has to be carried out. The handshake
establishes parameters such as protocol version, cryptographic algorithms, and shared
secrets. The TLS handshake involves hello messages for establishing algorithms, exchanging
random values, and checking for earlier sessions. Then cryptographic parameters are shared
in order to agree on a shared premaster secret. The parties authenticate each other via
public key encryption, generate a shared master secret based on the premaster secret, and
finally verifies that their peer has the correct security parameters. The DTLS handshake
adds to this a stateless cookie exchange to prevent DoS attacks, some modifications to the
handshake header to make communication over UDP possible, and retransmission timers since
the communication is unreliable. Otherwise the DTLS handshake is as the TLS handshake.

\subsection{CoAP}
\label{ssec:coap}
CoAP is an application layer protocol designed to be used by constrained devices over networks
with low throughput and possibly high unreliability for machine-to-machine communication
\parencite{rfc7252}. While designed for constrained networks, a design feature of CoAP is
how it is easily interfaced with HTTP so that communication over traditional networks can
be proxied. Furthermore, CoAP is a REST based protocol utilizing application endpoints, a
subset of standardised request/response codes, URIs, and MIME types \parencite{rest}.
Additionally CoAP offers features such as multicast support, asynchronous messages, low
header overhead, and UDP and DTLS bindings which are all suitable for constrained
environments.

As CoAP is usually implemented on top of UDP, communication is stateless and asynchronous.
For this reason CoAP defines four message types: Confirmable, Non-confirmable,
Acknowledgement, and Reset. These message types are combined with a subset of HTTP method
codes. Confirmable messages must be answered with a corresponding Acknowledgement, this
provides one form of reliability over an otherwise unreliable channel. Non-confirmable
messages do not require an Acknowledgement and thus act asynchronously. Reset messages are
used when a recipient is unable to process a Non-confirmable message. Confirmable,
Non-confirmable, and Acknowledgement messages all use Message IDs in order to detect
duplicate messages in case of retransmission.

Since CoAP is based on unreliable means of transport, there are some lightweight
reliability and congestion control mechanics in CoAP. Message IDs allows for detection of
duplicate messages and tokens allow asynchronous requests and responses be paired
correctly. There is also a retransmission mechanic with an exponential back-off timer for
Confirmable messages so that lost Acknowledgements does not cause a flood of
retransmissions. There is also an option in CoAP for clients to observe, or subscribe, to
a resource and be notified by the server when that resource changes.

A feature of CoAPs messaging model is the piggybacked respones. If a response to a
Confirmable or Non-confirmable request is immediately available and fits in the
Acknowledgement, the response itself can be delivered with the Acknowledgement. If the
response is not available, a recepient can respond with an empty Acknowledgement and later
send a Confirmable message containing the response. Requests use the GET, PUT, POST, and
DELETE methods in a manner that is very similar but not identical to HTTP.

Figure \ref{fig:coap} shows the CoAP message format. The 2-bit version (Ver) field
indicates the CoAP version, which at time of writing is 1 (01 in binary). The 2-bit type
(T) field determines the type of message (Confirmable, Non-confirmable, Acknowledgement,
Reset). Token length (TKL) indicates the length of the Token field which can vary between
zero to eight bytes. The 8-bit code field carries which method code the message carries
and can be further broken into a 3-bit class and 5-bit detail. The class can indicate a
request (0), a success response (2), a client error response (4), or a server error
response (5), with the detail further specifying the status of the message. The message ID
is a 16-bit integer used to detect duplicate message and to match Acknowledgement or
Resets with their initiating requests.

Following the header is the zero to eight bit Token value, which in turn is follow by zero
or more Options. Lastly comes the optional payload, which if present is prefixed by a payload
marker (0xFF). The length of the payload is dependant on the carrying protocol, which in
this thesis will be DTLS. The length of the payload is calculated depending on the size of
the CoAP header, token, and options as well as maximum DTLS record size.

\begin{figure}
    \begin{bytefield}[bitformatting={\small}, bitwidth=1.1em]{32}
        \bitheader{0-31}\\
        \bitbox{2}{Ver} & \bitbox{2}{T} & \bitbox{4}{TKL} & \bitbox{8}{Code}
        & \bitbox{16}{Message ID}\\
        \bitbox[ltb]{32}{Token (if any, TKL bytes) $\dots$}\\
        \bitbox[ltb]{32}{Options (if any) $\dots$}\\
        \bitbox{8}{1 1 1 1 1 1 1 1} & \bitbox[ltb]{24}{Payload (if any) $\dots$}
    \end{bytefield}
    \caption{The CoAP message format.}
    \label{fig:coap}
\end{figure}

Since firmware images can be relatively large their size needs to be handled during
transportation. UDP and DTLS only supports fragmentation which can be problematic in
unreliable networks. To remedy this CoAP supports block-wise transfers
\parencite{rfc7959}. A Block option allows stateless transfer of a large file separated in
different blocks. Each block can be individually retransmitted and by using monotonically
increasing block numbers, the blocks can be reassembled. The size of blocks can also be
negotiated between server and client meaning they can always find a suitable block size,
making the mechanism quite flexible.

\section{SUIT}
\label{sec:suit}
The IETF SUIT (Software Updates for Internet of Things) working group aims to define a
firmware update solution that is interoperable and non-proprietary \parencite{suit}. The
solution shall be usable on Class 1 devices as defined in RFC 7228. These devices feature
~10 KiB of RAM and ~100 KiB code size, which makes it suitable for this thesis
\parencite{rfc7228}. The solution may be applied to more powerful devices. The working
group does not however try to define new transport or discovery mechanism, making their
proposal angostic of any particular technology. Subsection \ref{ssec:architecture}
presents the SUIT architecture and subsection \ref{ssec:information-model} presents the
SUIT information model.

\subsection{Architecture}
\label{ssec:architecture}
There is an Internet Draft by the SUIT group focusing on the firmware update architecture
\parencite{suit-architecture}. This draft describes the goals and requirements of the
architecture, although makes no mention of any particular technology. The overarching
goals of the update process is to thwart any attempts to flash unauthorized, possibly
malicious firmware images as well as protecting the firmware image's confidentiality.
These goals reduces the possibility of an attacker either getting control over a device or
reverse engineering a malicious but valid firmware image as an attempt to mount an attack.

In order to accept an image and update itself, a device must be presented with certain
information. Several decisions must be made before updating and the information comes in
form of a manifest. The next section will describe the requirements posted upon this
manifest in more detail. The manifest helps the device make important decisions such
as if it trusts the author of the new image, if the image is intact, if the image is
applicable, where the image should be stored and so on. This in turns means the device
also has to trust the manifest itself, and that both manifest and update image must be
distributed in a safe and trusted architecture. The draft \parencite{suit-architecture}
presents ten qualitative requirements this architecture should have:
\begin{itemize}
    \item Agnostic to how firmware images are distributed:\\
            As this thesis aims to implement a prototype of an update mechanism, some
            choices about technology has to be done. This will realistically mean only a
            subset of the SUIT standard will be implemented as certain parts of the
            standard is not applicable. The proposed network stack uses UDP, DTLS, and
            CoAP for transportation and the target devices are Firefly devices running
            the Contiki-NG operating system.
    \item Friendly to broadcast delivery:\\
            Broadcasting will not be of main concern in this thesis.
    \item Use state-of-the-art security mechanisms:\\
            The SUIT standard assumes a PKI is in place. RISE has previously developed a
            PKI suitable for IoT, this PKI is an underlying assumption for the thesis. The
            PKI will allow for signing of the update manifest and firmware image.
    \item Rollback attacks must be prevented:\\
            The manifest will contain metadata such as monotonically increasing sequence
            numbers and best-before timestamps to avoid rollback attacks.
    \item High reliability:\\
            This is an implementation requirement and depends heavily on the hardware of
            the target device. % TODO: Mention possibilities for the specific bootloader of Firefly?
    \item Operate with a small bootloader:\\
            This is also an implementation requirement. % TODO: Same as above?
    \item Small parser:\\
            It must be easy to parse the fields of the update manifest as large parser can
            get quite complex. Validation of the manifest will happen on the constrained
            devices which further motivates a small parser and thus less complex
            manifests.
    \item Minimal impact on existing firmware formats:\\
            The update mechanism itself must not make assumptions of the current format of
            firmware images, but be able to support different types of firmware images.
    \item Robust permissions:\\
            This requirement is directed towards the administration of firmware updates
            and how different roles interact with the devices. The thesis will not
            consider any infrastructure outside of transporting manifest and image and
            applying the update such as device management, but will consider authorisation
            of parties through techniques like signing.
    \item Operating modes:\\
            The draft presents three broad modes of updates: client-initiated updates,
            server-initiated updates, and hybrid updates, where hybrids are mechanisms
            that require interaction between the device and firmware provider before
            updating. The thesis will look into all three of these broad classes.
\end{itemize}

An example architecture encompassing a device, a firmware update author, a firmware
server, a network operator and a device operator is presented in the draft. The author and
the device ineract with the firmware server in order to communicate firmware updates and
possibly manifests. The communication of the device as well as the updating itself is the
concern of this thesis. The draft also presents device management for the device operator
so that it is possible to track the state of updates in a network. Device management is
considered out of scope for this thesis.

The distribution of manifest and firmware image is also discussed, with a couple of
options being possible. The manifest and image can be distributed together to a firmware
server. The device then recieves the manifest either via pulling or pushing and can
subsequently download the image. Alternatively, the manifest itself can be directly sent
to the device without a need of a firmware server, while the firmware image is put on the
firmware server. After the device has receieved the lone manifest through some method, the
firmware can be downloaded from the firmware server. The SUIT architecture does not
enforce a specific method to be used when delivering the manifest and firmware, but states
that an update mechanism must support both types.

% TODO: Images showing the differences of distribution

\subsection{Information Model}
\label{ssec:information-model}
The corresponding Internet Draft for the SUIT information model presents the information
needed in the manifest to secure a firmware update mechanism
\parencite{suit-information-model}. It also presents threats, classifies them according to
the STRIDE model, and presents security requirements that map to the threats
\parencite{stride}. FInally it presents use cases and maps usability requirements to the
use cases in order to motivate the presence of the manifest elements. Since the thesis
makes a choice about specific technologies to use, not all use cases, usability
requirements, and manifest elements are deemed necessary. The threats and security
requirements however are. Note that the information model does not discuss threats outside
of transporting the updates, such as physical attacks.

The proposed manifest elements and their brief motivations can be seen in Table
\ref{tab:manifest-elements}. For more detailed motivations and requirements, refer to
\parencite{suit-information-model}.

\begin{longtable}[]{@{}lll@{}}
    \caption{The proposed manifest elements of the SUIT information model.}
    \label{tab:manifest-elements}\\
    \toprule
    \begin{minipage}[b]{0.23\columnwidth}\raggedright\strut
    Manifest Element\strut
    \end{minipage} & \begin{minipage}[b]{0.26\columnwidth}\raggedright\strut
    Status\strut
    \end{minipage} & \begin{minipage}[b]{0.60\columnwidth}\raggedright\strut
    Motivation/Notes\strut
    \end{minipage}\tabularnewline
    \midrule
    \endhead
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Version identifier\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Describes the iteration of the manifest format\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Monotonic Sequence Number\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Prevents rollbacks to older images\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Payload Format\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Describes the format of the payload\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Storage Location\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Tells the device which component is being updated, can be used to
    establish physical location of update\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Payload Digest\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    The digest of the payload to ensure authenticity. Must be possible to
    specify more than one payload digest indexed by XIP Address\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    XIP Address\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    -\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Used to specify which address the payload is for in systems with several
    potential images\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Size\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    The size of the payload in bytes\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Signature\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    The manifest is to be wrapped in an authentication container (not a
    manifest element itself)\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Dependencies\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    A list of digest/URI pairs linking manifests that are needed to form a
    complete update\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Precursor Image Digest Condition\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory (for differential updates)\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    If a precursor image is required, the digest condition of that image is needed\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Content Key Distribution Method\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Mandatory (for encrypted payloads)\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Tells how keys for encryption/decryption are distributed\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Vendor ID Condition\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Recommended\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Helps distinguish products from different vendors\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Class ID Condition\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Recommended\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Helps distinguish incompatible devices in a vendors infrastructure\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    \strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    \strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    \strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Required Image Version List\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Optional\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    A list of versions that must be present to apply an update which applies
    to multiple versions of a firmware\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Best-Before Timestamp Condition\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Optional\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    Tells the last application time\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Component Identifier\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Optional\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    For heterogeneous storages, identifies which part is to store the
    payload\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    URIs\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Optional\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    A list of weighted URIs used to obtain the payload\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Directives\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Optional\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    A list of instructions on processing the manifest. Applies to the entire
    manifest, unlike ``Processing Steps''\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Aliases\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    Optional\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    A list of digest/URI pairs\strut
    \end{minipage}\tabularnewline
    \begin{minipage}[t]{0.23\columnwidth}\raggedright\strut
    Processing Steps\strut
    \end{minipage} & \begin{minipage}[t]{0.26\columnwidth}\raggedright\strut
    -\strut
    \end{minipage} & \begin{minipage}[t]{0.60\columnwidth}\raggedright\strut
    A list of payload processors needed to process a nested format\strut
    \end{minipage}\tabularnewline
    \bottomrule
\end{longtable}

% TODO: Which manifest elements are deemed most useful/needed? Is this a question for the design
% part of the thesis?

To summarize, the SUIT information model proposes to use a signed manifest that is
distributed to each device in need of an update. The device then processes the manifest in
order to determine if the update is trusted, suitable, up to date, with many other
optional elements such as if other precursor images, special processing steps, or new URIs
to fetch the images are needed. The model does not make assumptions about technology which
is one of the reasons there are optional elements, not all of them are applicable to all
solutions. Nevertheless, the architecture and information model together provides a solid
base on which to design a secure update mechanism for IoT.

\section{Contiki-NG}
\label{ssec:contiki-ng}
% TODO: For details on image flipping/bootloaders, talk to Niclas
Contiki-NG is an open-source operating system for resource constrained IoT devices based
on the Contiki operating system \parencite{contiki-ng-github}, \parencite{contiki-github}.
Contiki-NG focuses on low-power communication and standard protocols and comes with
IPv6/LoWPAN, DTLS, and CoAP implementations which makes it a suitable operating system for
this thesis. Furthermore, Contiki-NG is open source and licensed under the permissive BSD
3-Clause license and targets a wide variety of boards which makes it align with SUITs goal
of creating an open standard for updating IoT devices.

Subsection \ref{ssec:process-event-memory} explains processes, events, and memory
management in Contiki-NG. These internals are heavily based on the previous Contiki
operating system and much of the information is gathered from there. Subsection
\ref{ssec:timers} presents the different timers available in Contiki-NG and their
different usages. Finally, subsection \ref{ssec:networking-contiki} presents part of the
network protocol stack that is implemented in standard Contiki-NG.

\subsection{Processes, Events, And Memory Management}
\label{ssec:process-event-memory}
Contiki-NG has a process abstraction which is built on lightweight protothreads
\parencite{protothreads}. A process is declared through a \texttt{PROCESS} macro and can
be automatically started after system boot or when a specific module is loaded. User-space
processes are run in a cooperative manner while kernel-space processes can preempt
user-space processes. Contiki-NGs execution model is event based, meaning processes often
yield execution until they are informed a certain event has taken place, upon which they
can act. Examples of events are timers expiring, a process being polled, or a network
packet arriving. 

Contiki-NG provides to memory allocators in addition to using static memory. They are
called \texttt{MEMB} and \texttt{HeapMem} and are semi-dynamic and dynamic, respectively.
\texttt{MEMB} provides ways to manage memory blocks. The memory blocks are allocated on
static memory as arrays of constant sized objects. After a memory block has been declared,
it is initialized after which objects can be allocated memory from the block. All objects
allocated through the same block have the same size. Blocks can be freed, and it is
possible to check whether a pointer resides within a certain memory block or not.

\texttt{HeapMem} solves the issue of dynamically allocating objects of varying sizes
during runtime in Contiki-NG. It can be used on a variety of hardware platforms, something
a standard C \texttt{malloc} implementation could struggle with. To allocate memory on the
heap, the number of bytes to allocate must be provided and a pointer to a contiguous piece
of memory is returned (if there is enough contiguous memory). Memory can be reallocated
and deallocated such as using a normal \texttt{malloc}.

\subsection{Timers}
\label{ssec:timers}
Contiki-NG provides different timers used by both the kernel and user-space applications.
The timers are based on the clock module which is responsible for handling system time.
The definition of system time is platform dependent.

The different timers and their usages are:
\begin{itemize}
    \item \texttt{timer}: a timer without built-in notification.
    \item \texttt{stimer}: counts in seconds and has a long wrapping period.
    \item \texttt{etimer}: schedules events to processes. Since events in Contiki-NG
            can put yielding processes in the execution state, \texttt{etimer} can be
            used to periodically schedule code by setting up an \texttt{etimer} to
            signal a specific event when it expires then waiting on that event
    \item \texttt{ctimer}: schedules calls to a callback function. \texttt{ctimer}
            works in similar ways to etimer but with callbacks to callback functions
            instead of events.
    \item \texttt{rtimer}: schedules real-time tasks. Since real-time tasks face
            different requirements than normal tasks, rtimer uses a higher resolution
            clock. Real-time tasks preempt normal execution so that the real-time task can
            execute immediately. This mean there are constraints on what can be done in
            real-time tasks as many functions cannot handle preemption.
\end{itemize}

\texttt{timer}, \texttt{stimer}, and \texttt{rtimer} as stated to be safe from interrupts
while \texttt{etimer} and \texttt{ctimer} are unsafe. All timers are declared using a timer
struct, which is also how the timer is interacted with.

\subsection{Networking Protocols in Contiki-NG}
\label{ssec:networking-contiki}
Contiki-NG features an IPv6 network stack designed for unreliable, low-power IoT networks.
There are many protocols implemented in the stack, this thesis will look at UDP and CoAP
secured by DTLS. Beneath IPv6 Contiki-NG supports IEEE 802.15.4 with TSCH
\parencite{ieee-802.15.4}.

The CoAP implementation in Contiki-NG is based on Erbium by Mattias Kovatsch but has
become part of core modules in the operating system itself \parencite{low-power-coap}. The
default implementation supports both unsecured (CoAP) and secured (CoAPs) communication.
CoAPs uses a DTLS implementation called TinyDTLS which handles encryption and decryption
of messages \parencite{tinydtls-github}. The CoAP implementation consists of:

\begin{itemize}
    \item a CoAP engine which registers CoAP resources
    \item a CoAP handler API that allows for implementations of resource handlers. The
        handlers act upon incoming messages to their corresponding resource
    \item a CoAP endpoint API allowing handling of different kinds of CoAP endpoints.
    \item a CoAP transport API which hands CoAP data from the CoAP stack to the transport
    protocol.
    \item CoAP messages functions for parsing and creating messages
    \item a CoAP timer API providing timers for retransmission mechanisms.    
\end{itemize}


\section{EST-coaps}
\label{ssec:est-coaps}
EST-coaps is a protocol for certificate enrollment in constrained environments using CoAP.
\parencite{est-coaps}. By allowing IoT devices to enroll for certificates, assymetric
encryption can be used even in a constrained environment. EST-coaps is heavily based on
EST which was developed for traditional, less constrained networks and is thus unsuitable
to be used with the SUIT standard \parencite{rfc7030}. EST-coaps retains much of the
functionality and structure of EST but modifies it slightly to work over CoAP, DTLS, and
UDP instead of HTTP, TLS, and TCP, for instance by making use of CoAPs block requests and
responses to remedy the relatively large sizes of certificates.

\section{Firefly}
\label{sec:hardware}
Zolertia Firefly is the targeted board for this thesis. It is a breakout board designed
for IoT application development and is supported by Contiki-NG. The board sports an ARM
Cortex-M3 with 512 KB flash and 32 KB RAM, making it more powerful than the Class 1
devices the SUIT standard targets. This is not an issue but should be kept in mind as less
capable devices are supposed to be able to use an update mechanism complying with SUIT.
Furthermore the board supports IEEE 802.15.4 communication in the 2.4 GHz band and SHA2
and RSA hardware acceleration \parencite{firefly-datasheet}.

\end{document}