\documentclass[0-thesis.tex]{subfiles}

\begin{document}
% TODO: Dedicate this to transportation CoAP -> DTLS -> UDP
% TODO: Also format of manifest
% TODO: Encoding? CBOR?

\section{Manifest Format}
\label{sec:manifest-format}
% General intro to the chapter
% Maybe state assumptions about storage and computational capability of target devices?
As the target devices of the update mechanism are constrained IoT devices, the manifest
format must be designed with careful consideration. The format must be easy to parse in
order to reduce power consumption on devices and be small so that transportation of the
manifest is done as quickly as possible, but still contain all necessary information to
perform secure updates. This section will present the manifest format which is based on
the SUIT specification. It consists of mandatory, always present elements as well as
optional elements. The reasoning for splitting it into mandatory and optional elements is
to reduce the size of the common case, a singular update for a single MCU, while still
allowing more complex updates (such as differential updates or specifying components). The
manifest format can be created or generated by some party in JSON, encoded in CBOR for
efficient compression, then signed and sent over the network. Preferably the base manifest
should fit in a single CoAP message, but the CoAP block option can be used if the manifest
adds many options and thus grows.
%As a rule of thumb, each byte sent expends as
%much energy as roughly 8000 CPU cycles, so reducing the size of the manifest is of
%importance \parencite{interconnecting}.

Subsection \ref{ssec:mandatory-elements} explains the structure of the manifest. Optional
elements and their structure are explained in subsection \ref{ssec:options}. 

\subsection{Mandatory Elements}
\label{ssec:mandatory-elements}
% Show header format, motivate sizes
The mandatory elements of the manifest should facilitate singular updates for a homogenous
device supporting one MCU as this is the simplest use case for secure updates. This use
case updates the entire image at once, OS and code, and does not need to care for
different storage locations or components. By restricting the mandatory elements to
supporting these kinds of updates, the size of the always occuring elements can be
reduced. 

Different versions of manifests can feature different fields as an update mechanism
evolves, therefore the device needs to know what to expect from the manifest. This can be
encoded in a \textbf{manifest version ID}. Rollback attacks need to be prevented so that
old, vulnerable images cannot be applied. They can be mitigated through a \textbf{sequence
number}. Furthermore the \textbf{format} (ELF, binary, etc) and the \textbf{size} of the
image must be included. \textbf{Vendor and class IDs}, possibly \textbf{device ID}, must
also be included so that the device knows the image is applicable and will work. Lastly, a
\textbf{digest} of the image must be included so the device can be sure the image has not
been tampered with during transport. The \textbf{URI} from which the image can be fetched
is bundled together with the digest. The manifest structure expressed as a C struct can be
seen in Listing \ref{lst:manifest-struct}.

\begin{lstlisting}[caption={The mandatory manifest format.}, 
                    label={lst:manifest-struct}]
    struct Manifest {
        int version;
        int sequenceNumber;
        int format;
        int size;
        Condition* condition;
        URIDigest* digest;
        Option* option;
    } Manifest;
\end{lstlisting}

These elements are deemed absolutely necessary and form the very minimum upon which an
update mechanism can operate. A manifest containing these and only these elements can be
used to perform a singular update for a device containing one MCU and one means of storage
(no ambiguity about which components/locations are being updated).

The digests, conditions, and options are nested structures that can possibly be repeated
depending on how many digests, conditions, and options are necessary. In order to
implement this, each of these structures contain an element which is a pointer to another
structure of the same type. This allows a parser to traverse the link of structures, and
thus parse several URI/Digest pairs, conditions, or options. Their structures can be seen
in Listing \ref{lst:uridigest-struct}, Listing \ref{lst:condition-struct}, and Listing
\ref{lst:option-struct} in the next section.

\begin{lstlisting}[caption={The format of URI/digest pairs.}, 
                    label={lst:uridigest-struct}]
    struct URIDigest {
        int URILength;
        char* URI;
        char* digest;
        URIDigest* next;
    } URIDigest;
\end{lstlisting}

\begin{lstlisting}[caption={The format of vendor, class, and device ID conditions.}, 
                    label={lst:condition-struct}]
    struct Condition {
        int type;
        char* UUID;
        Condition* next
    } Condition;
\end{lstlisting}

\subsection{Options}
\label{ssec:options}
% Show options format, motivate sizes
The options provide additional value to the mechanism, but as the manifest aims to be as
small as possible they are not accounted for in the base manifest. Instead they can be
optionally included using the options field of the manifest. The included options must be
sorted by their option code in ascending order to calculate a delta between the current
and preceeding option. This is the way CoAP implements options, and it allows for a
smaller amount of bits to encode the option code when the codes get larger. The options
and their codes are presented in Table \ref{tab:option-codes}.

\begin{longtable}[]{@{}ll@{}}
    \caption{The optional elements of the manifest and their option codes.}
    \label{tab:option-codes}\\
    \toprule
    Option Code & Option Name\tabularnewline
    \midrule
    \endhead
    1 & directives (Instruction struct)\tabularnewline
    2 & processingSteps (Instruction struct)\tabularnewline
    3 & component\tabularnewline
    4 & dependencies (URIDigest struct)\tabularnewline
    5 & precursors (URIDigest struct)\tabularnewline
    6 & aliases (URIDigest struct)\tabularnewline
    7 & storage\tabularnewline
    8 & keyDist\tabularnewline
    9 & best-before\tabularnewline
    10 & payload (if small enough)\tabularnewline
    \bottomrule
\end{longtable}

The option field in the manifest format will contain a list of option structures, each
structure consisting of an option delta, option length, option value, and a pointer to the
next option as seen in Listing \ref{lst:option-struct}. As with the mandatory elements,
some options consist of nested structs. The dependencies and precursor options list
digests of images or parts of images that must be acquired before applying the update,
along with their URLs. Aliases lists alternative mirrors for each image that could be used
instead. Directives and processingSteps both use a different kind of structure, an
Instruction struct, that maps types of instructions to their values. Examples of
directives could be when to install the update, and examples of processingSteps could be
which decompression algorithm to use. The Instruction struct can be seen in Listing
\ref{lst:instruction}.

\begin{lstlisting}[caption={The format of the option field.}, 
                    label={lst:option-struct}]
    struct Option {
        int delta;
        int length;
        char* value;
        Option* next;
    } Option;
\end{lstlisting}

\begin{lstlisting}[caption={The format of directives or processing steps.}, 
                    label={lst:instruction}]
    struct Instruction {
        int type;
        int value;
        Instruction* next;
    } Instruction;
\end{lstlisting}


\end{document}